import { store } from '../app.js'; // Pre-bundled, external reference
import { tables } from '../storage-webworker/openhabStoreLayout';

class ModelAdapter {
  constructor() {
    this.STORE_ITEM_INDEX_PROP = Object.freeze("id");
    this.runtimeKeys = []; this.items = []; this.itemlist = [];
  }
  stores() { return { "user-roles": "items" } };
  getall(options = null) {
    return store.get("items", null, { force: true })
      .then(json => this.itemlist = json)
      .then(() => this.get(options));
  }
  get(options = null) {
    return store.get("user-roles", null, options).then(items => this.items = items);
  }
  dispose() {
  }
}

const schema = {
  uri: 'http://openhab.org/schema/userrole-schema.json',
  fileMatch: ["http://openhab.org/schema/userrole-schema.json"],
  schema: {
    type: 'array',
    items: { "$ref": "#/definitions/item" },
    definitions: {
      item: {
        type: "object",
        description: "openHAB User Role",
        required: ["id", "label", "passwordhash"],
        properties: {
          id: { type: "string", description: "A unique ID for this user role", minLength: 2 },
          label: { type: "string", description: "A friendly name", minLength: 2 },
          annotation: { type: "string", description: "Your personal comment for this object" },
          description: { type: "string", description: "A user description" },
          password: { type: "string", description: "A password that will be converted to a password hash by openHAB" },
          passwordhash: { type: "string", description: "A password hash, generated by openHAB after a password has been transmitted" },
          tags: { type: "array", "uniqueItems": true, description: "Tags of this item" },
          items: { type: "array", "uniqueItems": true, description: "Items that this user role can access" },
          restEndpoints: { type: "string", description: "A regex that must match for accessing a REST endpoint" },
        }
      }
    }
  },
}


const ListMixin = {
  methods: {
    save: function () {
      this.message = null;
      this.messagetitle = "Saving...";
      this.inProgress = true;
      this.changed = false;
      setTimeout(() => this.inProgress = false, 1000);
    },
    remove: function () {
      this.message = null;
      this.messagetitle = "Removing...";
      this.inProgress = true;
    },
  }
}

const ItemListMixin = {
  mounted() {
    this.modelschema = Object.freeze(schema);
  },
  methods: {
    saveAll: function (items) {
      //TODO
      console.log("save all", items);
    },
  },
  computed: {
    restEndpoints() {
      return tables.filter(e => e.label);
    }
  }
};

const mixins = [ListMixin];
const listmixins = [ItemListMixin];

export { mixins, listmixins, ModelAdapter };
